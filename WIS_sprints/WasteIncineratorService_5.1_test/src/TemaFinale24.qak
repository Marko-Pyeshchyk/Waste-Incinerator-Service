System wis24

Event burn_end : burn_end(N)

// incinerator
Dispatch activation_command:activation_command(N)
Dispatch burn_start:burn_start(N)
Dispatch ash_taken:ash_taken(N)

// waste storage
Dispatch rp_number:rp_number(N)
Dispatch kg:kg(N)

// monitornig device
Dispatch burn_end:burn_end(X)

Dispatch sonar_value:sonar_value(K)

Dispatch led_on:led_on(N)
Dispatch led_off:led_off(N)
Dispatch led_flashing:led_flashing(N)

Event sonardata:sonardata(K)

// op robot
Request engage        : engage(OWNER, STEPTIME)	
Reply   engagedone    : engagedone(ARG)    for engage
Reply   engagerefused : engagerefused(ARG) for engage
Dispatch disengage    : disengage(ARG)

Dispatch cmd    : cmd( MOVE )  "MOVE = a|d|l|r|h   "

Request  cmd    : cmd(MOVE,T)  "MOVE = w|s|p (stepSynch)" 

Reply cmddone   : cmddone(R)          for cmd
Reply cmdfailed : cmdfailed(T,CAUSE)  for cmd

Request step       : step(TIME)	
Reply stepdone     : stepdone(V)                 for step
Reply stepfailed   : stepfailed(DURATION, CAUSE) for step

Request moverobot    :  moverobot(TARGETX, TARGETY)
Reply moverobotdone  :  moverobotok(ARG)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot 

Dispatch take_RP : take_RP(X)
Dispatch take_ash : take_RP(X)
Dispatch go_home : take_RP(X)
Dispatch work : work(X)

Dispatch primo : primo(X)
Dispatch secondo : secondo(X)
Dispatch terzo : terzo(X)
Dispatch quarto : quarto(X)
Dispatch quinto : quinto(X)

// test
Request test_request:test_request(N)
Reply test_reply:test_reply(N) for test_request

// context
Context ctxwis  ip [host="localhost" port=8080] 
Context ctxbrobot ip [host="127.0.0.1" port=8020] 

ExternalQActor basicrobot context ctxbrobot 

QActor op_robot  context ctxwis {
	[# 
		var X = 0
		var Y = 0
		#
	]    
	State s0 initial {
		println("$name	START") color cyan
		delay 1000
		subscribeTo incinerator for burn_end
		request basicrobot -m engage : engage($MyName,135)
	}
	Transition t0 whenReply engagedone -> ready
				  whenReply engagerefused -> end
	
	State end {
		println("$name ENDS ") color cyan
	}
	
	State ready {
			println("$name	READY") color cyan
			forward wis -m work:work(waiting_home)
			forward basicrobot -m cmd:cmd(a)
			forward basicrobot -m cmd:cmd(d)
	}
	Transition t1 whenMsg take_RP -> menage_RP
				  whenMsg go_home -> going_HOME
				  whenMsg take_ash -> menage_ash
	
	
	State menage_RP {
		[#
			X = 0
			Y = 4
		#]
		forward wis -m work:work(moving_to_WASTEIN)
		request basicrobot -m  moverobot : moverobot(0,4)
	}
	Transition t0 //whenTime 5000 -> menage_RP
				  whenReply moverobotdone -> menage_RP2
				  whenReply moverobotfailed -> handle_obstacle
	
	State menage_RP2 {
		[#
			X = 3
			Y = 1
		#]
		forward wis -m work:work(taking_RP)
		delay 1000
		forward wis -m work:work(moving_to_BURNIN)
		request basicrobot -m  moverobot : moverobot(3,2)
	}
	Transition t0 whenReply moverobotdone -> menage_RP3
				  whenReply moverobotfailed -> handle_obstacle
		
	State menage_RP3 {
		forward wis -m work:work(putting_RP)
		delay 1000
		forward wis -m work:work(waste_in_incinerator)
	}
	Goto going_HOME
	
	State menage_ash {
		[#
			X = 5
			Y = 3
		#]
		forward wis -m work:work(moving_to_BURNOUT)
		request basicrobot -m  moverobot : moverobot(4,3)
	}
	Transition t0 whenReply moverobotdone -> menage_ash2
				  whenReply moverobotfailed -> handle_obstacle
	
	State menage_ash2 {
		[#
			X = 6
			Y = 4
		#]
		forward wis -m work:work(taking_ash)
		delay 2000
		forward wis -m work:work(ash_taken)
		forward wis -m work:work(moving_to_ASHOUT)
		request basicrobot -m  moverobot : moverobot(6,4)
	}
	Transition t0 whenReply moverobotdone -> menage_ash3
				  whenReply moverobotfailed -> handle_obstacle
		
	State menage_ash3 {
		forward wis -m work:work(dumping_ash)
		delay 1000
		forward wis -m work:work(job_done)
	}
	Goto job_done
	
	State job_done {
			println("$name	JOB DONE") color cyan
	}
	Transition t1 whenMsg take_RP -> menage_RP
				  whenMsg go_home -> going_HOME
	
	State going_HOME {
		[#
			X = 0
			Y = 0
		#]
		println("GOING HOME GOING HOME GOING HOME") color cyan
		forward wis -m work:work(going_home)
		delay 2000
		request basicrobot -m  moverobot : moverobot(0,0)
		
		 //forward basicrobot -m disengage : disengage($MyName)
		 //[# System.exit(0) #]
	}
	Transition t0 whenReply moverobotdone -> ready
				  whenReply moverobotfailed -> handle_obstacle
	
 
	State handle_obstacle {
		println("$name	OBSTACLE hit") color cyan
		delay 3000
		if [# X==0 && Y==4 #] {
			autodispatch primo:primo(a)
		}else{
			if [# X==3 && Y==1 #] {
				autodispatch secondo:secondo(a)
			}else{
				if [# X==5 && Y==3 #] {
					autodispatch terzo:terzo(a)
				}else{
					if [# X==6 && Y==4 #] {
						autodispatch quarto:quarto(a)
					}else{
						if [# X==0 && Y==0 #] {
							autodispatch quinto:quinto(a)
						}
					}
				}
			}
		}
		
	}
	Transition t0 whenMsg primo -> menage_RP
				  whenMsg secondo -> menage_RP2
				  whenMsg terzo -> menage_ash
				  whenMsg quarto -> menage_ash2
				  whenMsg quinto -> going_HOME
}
 
 
// waste storage
QActor waste_storage  context ctxwis {   
	[# var RP:Int = 0 #]
	 
	State s0 initial {
		println("$name	START") color yellow
		delay 1000 
	}
	Transition t1 whenMsg kg -> convert_kg
	
	State convert_kg{
		onMsg( kg : kg(N) ){
			[# 
				var KG = payloadArg(0).toFloat()
				RP += kotlin.math.round(KG/50).toInt()
			#]
			println("$name	$KG Kg ===> $RP RP") color yellow
			forward wis -m rp_number:rp_number($RP)
		}
	}
	Transition t1 whenMsg kg -> convert_kg
}

// incinerator
QActor incinerator  context ctxwis {    
	[# var BTIME = 3000L #]
	State s0 initial {
		println("$name	START") color red
	} 
	Transition t1 whenMsg activation_command -> activated
		
	State activated {
		forward wis -m activation_command:activation_command(N)
	}
	Goto ready
	
	State ready {
		println("$name	READY") color red
	}
	Transition t1 whenMsg burn_start -> burning
	
	State burning {
		println("$name	burning...") color red
		delayVar BTIME
		println("$name	burn end") color red
		emit burn_end:burn_end(0) 
	}
	Transition t1 whenMsg ash_taken -> ready
	
}

QActor wis context ctxwis {
	[#
		var distance=999
		var rp_number=0
		var robot=""
		var incinerator="off"
		var robot_sent=0
		var ash_available=0
		var DLIMIT=300
		var RP_remove = -50
	#]
	State s0 initial {
		println("$name		START") color green
		delay 1000
		subscribeTo incinerator for burn_end
	}
	Goto ready
	
	State ready {
		println("$name		READY") color green
	}	
	Transition t1 whenMsg activation_command -> handle_activation
				  whenMsg sonar_value -> handle_sonar
				  whenMsg rp_number -> handle_rp_number
				  whenMsg work -> handle_robot_init
				  
	State handle_sonar{
		onMsg(sonar_value:sonar_value(K)){
			[# distance=payloadArg(0).toInt() #]
		}
	}
	Goto ready if [# incinerator=="off" #] else activated
	
	State handle_rp_number{
		onMsg(rp_number:rp_number(K)){
			[# rp_number=payloadArg(0).toInt() #]
		}
	}
	Goto ready if [# incinerator=="off" #] else activated
	
	State handle_robot_init{
		onMsg(work:work(K)){
			[# 
				robot=payloadArg(0) 
				var Work = payloadArg(0) 
			#]
			updateResource [#"work($Work)"#]
		}
	}
	Goto ready if [# incinerator=="off" #] else activated
	
	State handle_activation{
		[# incinerator="on" #]
	}
	Goto activated
	
	State activated {
		//println("$name		ACTIVE") color green
		println("$name	INFO:	rp_number: $rp_number	distance: $distance	incinerator: $incinerator		robot: $robot	ash: $ash_available") color green
		if [# rp_number>0 && distance>DLIMIT && incinerator!="burning" && (robot=="waiting_home" || robot=="job_done") && robot_sent==0 && ash_available==0 #] {
			forward op_robot -m take_RP:take_RP(X)
			[# robot_sent=1 #]
		}
		if [# distance>DLIMIT && incinerator=="on" && (robot=="waiting_home" || robot=="job_done") && robot_sent==0 && ash_available==1 #] {
			forward op_robot -m take_ash:take_ash(X)
			[# robot_sent=1 #]
		}
		if [# ((robot=="job_done" && rp_number==0) || (robot=="job_done" && distance<=DLIMIT) || (robot=="job_done" && incinerator=="burning")) && robot_sent==0 #] {
			forward op_robot -m go_home:go_home(X)
			[# robot_sent=1 #]
		}
	}
	Transition t1// whenTime 5000 -> activated//scoprire come funzia
				  whenMsg sonar_value -> handle_sonar
				  whenMsg rp_number -> handle_rp_number
				  whenEvent burn_end -> handle_ash
				  whenMsg work -> handle_work
				  
	State handle_work{
		onMsg(work:work(X)){
			[# robot=payloadArg(0) 
				var Work = payloadArg(0) #]
			updateResource [#"work($Work)"#]
			println("$name	ROBOT_STATE:	$robot") color green
		}
		[# robot_sent=0 #]
		if [# robot=="waste_in_incinerator" #]{
			[# incinerator="burning" #]
			forward incinerator -m burn_start:burn_start(0)
			forward monitoring_device -m burn_start:burn_start(0)
		}
		if [# robot=="ash_taken" #]{
			[# ash_available=0 #]
			forward incinerator -m ash_taken:ash_taken(0)
		}
		if [# robot=="taking_RP" #]{
			forward waste_storage -m kg:kg($RP_remove)
		}
	}
	Goto activated
				  
	State handle_ash{
		[# 
			ash_available=1 
			incinerator="on" 
		#]
		println("$name	BURNEND LETTO") color green
		forward monitoring_device -m burn_end:burn_end(0)
	}
	Goto activated
	
	State retrieve_ash {
		println("$name		robot will retrieve ash") color green
		forward op_robot -m take_ash:take_ash(X)
		delay 15000
		forward incinerator -m ash_taken:ash_taken(N)
		
		forward op_robot -m go_home:go_home(X)
	}
}

// external agents
QActor activator_mock context ctxwis {
	State s0 initial {
		delay 1000
		println("$name	START") color cyan
		forward incinerator -m activation_command:activation_command(N)
	}
}

QActor external_agent_ws context ctxwis {
	State s0 initial {
		delay 1000
		println("$name	START") color cyan
	}
	Transition t0 whenMsg kg -> send_kg
	
	State send_kg {
		onMsg(kg:kg(X)){
			[# var KG = payloadArg(0) #]
			forward waste_storage -m kg:kg($KG)
		}
	}
	Transition t0 whenMsg kg -> send_kg
}

// monitornig device

QActor monitoring_device context ctxwis{
	[#	val DLIMIT = 300;
		var max_dist = 0
		var Distance = 999;
		var burning = 0;
	#]
	State s0 initial{
		println("START MonitoringDevice") color red
	}
	Transition t0 whenMsg sonar_value -> handleSonar
				  whenMsg burn_start -> handleStart
				  whenMsg burn_end -> handleEnd
	
	State handleStart {
		[# burning = 1 #]
		if [# Distance>DLIMIT && Distance!=max_dist #] {
			forward led -m led_on:led_on(N)
		}
	}
	Transition t0 whenMsg sonar_value -> handleSonar
				  whenMsg burn_start -> handleStart
				  whenMsg burn_end -> handleEnd
				  
	State handleEnd {
		[# burning = 0 #]
		if [# Distance>DLIMIT && Distance!=max_dist #] {
			forward led -m led_off:led_off(N)
		}
	}
	Transition t0 whenMsg sonar_value -> handleSonar
				  whenMsg burn_start -> handleStart
				  whenMsg burn_end -> handleEnd
				  
	State handleSonar{
		onMsg(sonar_value:sonar_value(K)){
			[# Distance = payloadArg(0).toInt() #]
			println("$name			distance: $Distance") color red
			forward wis -m sonar_value:sonar_value($Distance)
			if [# max_dist<Distance #] {
				[# max_dist=Distance #]
			}
			if [# Distance<=DLIMIT #] {
				forward led -m led_flashing:led_flashing(N)
			} else {
				if [# max_dist==Distance #] {
					forward led -m led_flashing:led_flashing(N)
				} else {
					if [# burning==1 #] {
						forward led -m led_on:led_on(N)                             
					} else {
						forward led -m led_off:led_off(N)
					}
				}
			}
		}
	}
	Transition t0 whenMsg sonar_value -> handleSonar
				  whenMsg burn_start -> handleStart
				  whenMsg burn_end -> handleEnd
}

QActor led context ctxwis{
	State s0 initial{
		println("START led") color magenta
	}
	Transition t0 whenMsg led_on -> handleOn
				  whenMsg led_off -> handleOff
				  whenMsg led_flashing -> handleFlashing
				  
	State handleOn{
		println("LED ON") color magenta
		//turn on with python
	}
	Transition t0 whenMsg led_on -> handleOn
				  whenMsg led_off -> handleOff
				  whenMsg led_flashing -> handleFlashing
	
	State handleOff{
		println("LED OFF") color magenta
		//turn off with python
	}
	Transition t0 whenMsg led_on -> handleOn
				  whenMsg led_off -> handleOff
				  whenMsg led_flashing -> handleFlashing
				  
				  
	State handleFlashing{
		println("LED FLASHING") color magenta
		//turn flashing with python
	}
	Transition t0 whenMsg led_on -> handleOn
				  whenMsg led_off -> handleOff
				  whenMsg led_flashing -> handleFlashing
}

QActor sonar context ctxwis{
	State s0 initial{
		println("START sonar") color green
		delay 1000
		subscribeTo sonar_device for sonardata
	}
	Transition t0 whenEvent sonardata -> handleSonar
	
	State handleSonar{
		onMsg(sonardata:sonardata(K)){
			[# var D = payloadArg(0) #]
			forward monitoring_device -m sonar_value:sonar_value($D)
		}
	}
	Transition t0 whenEvent sonardata -> handleSonar
}

QActor sonar_device context ctxwis {
	[# 
		lateinit var process : Process
		lateinit var out : java.io.BufferedReader
		var Distance = 0
	#]
	
	State s0 initial {
		println("$name	START") color yellow
		[# 
			process = Runtime.getRuntime().exec("python sonar.py")
			out = process.getInputStream().bufferedReader()
		#]
	}
	Goto readOut
	
	State readOut {
		[# 
			var Distance =  out.readLine()	
		#]
		//println("$name	distance: $Distance") color yellow
		emitlocalstream sonardata:sonardata($Distance)
	}
	Goto readOut
	
	State sonar_limited {
		emitlocalstream sonardata:sonardata(0)
	}
}


QActor test_observer context ctxwis {
	[# 
		var A : String = "" 
		var Comulative : String = "" 
		var Test : String = ""
		var Jobs : Int = 0
	#]
	
	State s0 initial {
		delay 5000
		observeResource wis msgid work
	}
	Transition t0 whenRequest test_request -> handle_request
		
	State handle_request {
		onMsg(test_request:test_request(X)){
			[# Test = payloadArg(0) #]
		}
		println("$Test")
	}
	Goto test1 if [# Test == "1" #] else test2
	
	State test1 {
		println("$name	test 1") color cyan
		forward external_agent_ws -m kg:kg(50) 
	}
	Transition t0 whenMsg work -> send_data
	
	State test2 {
		println("$name	test 2") color cyan
		forward external_agent_ws -m kg:kg(100)
	}
	Transition t0 whenMsg work -> send_data
	
	State send_data {
		onMsg(work:work(X)){
			[# 
				A = payloadArg(0) 
				Comulative +=  A + ","
			#]
			//println("WORK:	$A	$Comulative") color cyan
			if [# A=="job_done" && Test=="1"#] {
				[# Comulative = "'"+ Comulative + "'" #]
				println("ending.......") color red
				replyTo test_request with test_reply:test_reply($Comulative)
				[# System.exit(0) #]
			}
			if [# A=="job_done" && Test=="2"#] {
				[# Jobs = Jobs+1 #]
				if [# Jobs == 2 #] {
					[# Comulative = "'"+ Comulative + "'" #]
					replyTo test_request with test_reply:test_reply($Comulative)
					[# System.exit(0) #]
				}
			}
		}
	}
	Transition t0 whenMsg work -> send_data
}